# 設計模式

## 物件導向(Object-Oriented Programming)

### Class 三大特性

| 特性 | 說明                               |
| ---- | ---------------------------------- |
| 封裝 | 類對其他物件只公開有限的接口       |
| 繼承 | 類可以擴展，子類擁有父類相同的接口 |
| 多形 | 接口一樣，可以有不同的行為         |

### 關係

| 關係 | 說明                                                    |
| ---- | ------------------------------------------------------- |
| 依賴 | 類 B 修改會影響類 A                                     |
| 關聯 | 物件 A 使用物件 B                                       |
| 聚合 | 物件 A 使用物件 B 且由 B 組成                           |
| 組合 | 物件 A 使用物件 B 且由 B 組成並管理生命週期             |
| 實現 | 物件 A 的接口由類 B 聲明，物件 A 可視為物件 B           |
| 繼承 | 物件 A 的接口由類 B 聲明且對其擴展，物件 A 可視為物件 B |

## GRASP 設立原則

- 信息專家原則(information)
  - 若一個類擁有完成這個角色所需要的資訊，則把這個角色分配給這個類
- 建立者原則(creator)
  - 誰應該負責產生某個類的實例
- 低耦合原則(low coupling)
  - 物件與物件間的相依性低，複用性就高
- 高內聚原則(high cohesion)
  - 物件內的功能是彼此緊密有關的，高度聚合的
- 控制器原則(controller):
  - 事件的邏輯處理委託給一個物件
- 多態原則(polymorphism)
  - 根據類型變化分配職責
- 純虛構(pure fabrication)
  - 只需要模擬屬性和行為，不需要準確的實現
- 中介原則(indirect)
  - 建立中間對象協調 2 個對象間的交互，避免高耦合度
- 保護變量原則(protected variations)
  - 保護物件，不受其他物件變化影響。

## SOLID 設計原則

- 單一責任原則(Single Responsibility Principle)
  - 一個物件只對唯一一個角色負責
- 開放封閉原則(Open Closed Principle)
  - 物件應該對擴展開放，對修改封閉
- 里氏替換原則(Liskov Substitution Principle)
  - 子類物件必須能夠完全替換父類物件
- 接口分離原則(Interface Segregation Principle)
  - 縮小其接口，不必實例化不需要的接口
- 依賴反向原則(Dependency Inversion Principle)
  - 依賴於抽象接口，而不是實例

## 創建型模式(Creational)

創建型模式提供創建物件的機制，能夠提供已有代碼的靈活性和可複用性

| 設計模式   | 英文名稱   | 說明                                                             |
| ---------- | ---------- | ---------------------------------------------------------------- |
| 工廠方法   | Factory    | 在父類中提供一個創建的方法，允許子類決定實例化物件的類型         |
| 抽象工廠   | Abstract F | 創建一系列的物件，而無許指定其具體類                             |
| 單例模式   | Singletion | 保證一個類只有一個實例，並提供一個訪問該實例的參數               |
| 建造者模式 | Builder    | 能夠分步驟創建複雜物件，允許使用相同代碼生成不同類型和形式的物件 |
| 原型模式   | Prototype  | 能夠複製已有物件，而無須使代碼依賴所屬的類                       |

## 結構型模式(Structural)

結構型模式介紹如何將物件和類組裝成較大的結構，並同時保持結構的靈活和高效

| 設計模式   | 英文名稱  | 說明                                                         |
| ---------- | --------- | ------------------------------------------------------------ |
| 適配器模式 | Adapter   | 接口不兼容的物件能夠互相合作                                 |
| 橋接模式   | Bridge    | 可將緊密相關的類拆分成抽象和實現兩個獨立層次結構             |
| 組合模式   | Composite | 將物件組合成樹狀結構，並且能象使用獨立物件一樣使用           |
| 裝飾器模式 | Decorator | 允許透過將物件放入行為的特殊封裝物件來為原物件幫綁定新的行為 |
| 門面模式   | Facade    | 能為框架或其他複雜類提供一個簡單的接口                       |
| 享元模式   | Flyweight | 共享多個物件所共有的相同狀態，能在有限的容量載入更多物件     |
| 代理模式   | Proxy     | 提共物件的代理，代理控制對於原物件的訪問，允許請求前的處理   |

## 行為型模式(Behavioral)

行為型模式負責物件間的高效溝通和職責委派

| 設計模式   | 英文名稱 | 說明                                                           |
| ---------- | -------- | -------------------------------------------------------------- |
| 責任鏈模式 | COR      | 將請求沿著練進行發送，每個處理者都可對請求進行處理，並傳遞下去 |
| 命令模式   | Command  | 將請求轉換為一個包含與請求相關的訊息的物件，能夠特殊處理請求   |
| 迭代器模式 | Iterator | 能在不暴露集合底層形式的情況下遍歷集合中所有元素               |
| 中介者模式 | Mediator | 減少物件之間依賴關係，限制物件的直接交互，須依中介者進行合作   |
| 備忘錄模式 | Memento  | 允許再不暴露物件細節的情況下，保存和恢復物件之前的狀態         |
| 觀察者模式 | Observer | 允許定義一種訂閱機制，當物件事件發生時通知觀察該物件的其他物件 |
| 狀態模式   | State    | 在物件內部狀態變化時改變其行為                                 |
| 策略模式   | Strategy | 能讓你定義一系列邏輯，並將邏輯放入獨立的類中                   |
| 模板模式   | Template | 定義一個邏輯的框架，允許子類在不修改結構下重寫邏輯的特定步驟   |
| 訪問者模式 | Visitor  | 將邏輯與其作用物件隔離開來                                     |

## 參考資料

- [菜鳥教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [圖說設計模式](https://design-patterns.readthedocs.io/zh-cn/latest/index.html)
- [深入設計模式](https://refactoring.guru/design-patterns)
